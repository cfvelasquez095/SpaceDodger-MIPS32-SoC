/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module PriorityEncoder3 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    output reg [2:0] num,
    output any
);
    always @ (*) begin
        if (in7 == 1'b1)
            num = 3'h7;
        else if (in6 == 1'b1)
            num = 3'h6;
        else if (in5 == 1'b1)
            num = 3'h5;
        else if (in4 == 1'b1)
            num = 3'h4;
        else if (in3 == 1'b1)
            num = 3'h3;
        else if (in2 == 1'b1)
            num = 3'h2;
        else if (in1 == 1'b1)
            num = 3'h1;
        else 
            num = 3'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7;
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module ControlUnit (
  input rst,
  input [5:0] Opcode,
  output memWrite,
  output memRead,
  output memToReg,
  output [2:0] aluOp,
  output RegDst,
  output aluSrc,
  output RegWrite,
  output beq,
  output jump,
  output bne
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire [2:0] s6;
  wire [11:0] s7;
  wire [11:0] s8;
  // R_format
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( Opcode ),
    .b( 6'b0 ),
    .\= ( s0 )
  );
  // SW
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( Opcode ),
    .b( 6'b101011 ),
    .\= ( s1 )
  );
  // LW
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i2 (
    .a( Opcode ),
    .b( 6'b100011 ),
    .\= ( s2 )
  );
  // beq
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i3 (
    .a( Opcode ),
    .b( 6'b100 ),
    .\= ( s3 )
  );
  // bne
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i4 (
    .a( Opcode ),
    .b( 6'b101 ),
    .\= ( s4 )
  );
  // jmp
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i5 (
    .a( Opcode ),
    .b( 6'b10 ),
    .\= ( s5 )
  );
  PriorityEncoder3 PriorityEncoder3_i6 (
    .in0( s0 ),
    .in1( s1 ),
    .in2( s2 ),
    .in3( s3 ),
    .in4( s4 ),
    .in5( s5 ),
    .in6( 1'b0 ),
    .in7( 1'b0 ),
    .num( s6 )
  );
  Mux_8x1_NBits #(
    .Bits(12)
  )
  Mux_8x1_NBits_i7 (
    .sel( s6 ),
    .in_0( 12'b101111000 ),
    .in_1( 12'b10010001 ),
    .in_2( 12'b110010110 ),
    .in_3( 12'b1000011000 ),
    .in_4( 12'b10000011000 ),
    .in_5( 12'b100000111000 ),
    .in_6( 12'b0 ),
    .in_7( 12'b0 ),
    .out( s7 )
  );
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i8 (
    .sel( rst ),
    .in_0( s7 ),
    .in_1( 12'b0 ),
    .out( s8 )
  );
  assign memWrite = s8[0];
  assign memRead = s8[1];
  assign memToReg = s8[2];
  assign aluOp = s8[5:3];
  assign RegDst = s8[6];
  assign aluSrc = s8[7];
  assign RegWrite = s8[8];
  assign beq = s8[9];
  assign bne = s8[10];
  assign jump = s8[11];
endmodule

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module PCDecoder (
  input [31:0] VirtualPC,
  output [9:0] PhysicalPC,
  output InvalidPC
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire [31:0] s5;
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i0 (
    .a( VirtualPC ),
    .b( 32'b10000000000000000000000 ),
    .\> ( s0 ),
    .\= ( s1 )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i1 (
    .a( VirtualPC ),
    .b( 32'b10000000000001111111111 ),
    .\= ( s2 ),
    .\< ( s3 )
  );
  assign s4 = ((s0 | s1) & (s2 | s3));
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i2 (
    .sel( s4 ),
    .in_0( 32'b0 ),
    .in_1( VirtualPC ),
    .out( s5 )
  );
  Mux_2x1 Mux_2x1_i3 (
    .sel( s4 ),
    .in_0( 1'b1 ),
    .in_1( 1'b0 ),
    .out( InvalidPC )
  );
  assign PhysicalPC = s5[9:0];
endmodule
module DIG_ROM_256X32_InstMem (
    input [7:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:2];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 8'h2)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'h8c080000;
        my_rom[1] = 32'h8c090004;
        my_rom[2] = 32'hac080008;
    end
endmodule

module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule




module ALUControl (
  input [2:0] aluOp,
  input [5:0] Func,
  output [2:0] aluFunc
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire [2:0] s6;
  wire s7;
  wire [2:0] s8;
  wire s9;
  // ADD
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( Func ),
    .b( 6'b100000 ),
    .\= ( s0 )
  );
  // AND
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( Func ),
    .b( 6'b100100 ),
    .\= ( s1 )
  );
  // OR
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i2 (
    .a( Func ),
    .b( 6'b100101 ),
    .\= ( s2 )
  );
  // SUB
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i3 (
    .a( Func ),
    .b( 6'b100010 ),
    .\= ( s3 )
  );
  // SLT
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i4 (
    .a( Func ),
    .b( 6'b101010 ),
    .\= ( s4 )
  );
  CompUnsigned #(
    .Bits(3)
  )
  CompUnsigned_i5 (
    .a( aluOp ),
    .b( 3'b111 ),
    .\= ( s9 )
  );
  // XOR
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i6 (
    .a( Func ),
    .b( 6'b100110 ),
    .\= ( s5 )
  );
  PriorityEncoder3 PriorityEncoder3_i7 (
    .in0( s1 ),
    .in1( s2 ),
    .in2( s0 ),
    .in3( s3 ),
    .in4( s4 ),
    .in5( s5 ),
    .in6( 1'b0 ),
    .in7( 1'b0 ),
    .num( s6 ),
    .any( s7 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i8 (
    .sel( s7 ),
    .in_0( 3'b101 ),
    .in_1( s6 ),
    .out( s8 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i9 (
    .sel( s9 ),
    .in_0( aluOp ),
    .in_1( s8 ),
    .out( aluFunc )
  );
endmodule
module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule


module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module ALU (
  input [31:0] a,
  input [31:0] b,
  input [2:0] op,
  output [31:0] res,
  output isZero
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [31:0] s4;
  wire [31:0] s5;
  wire [31:0] s6;
  wire [31:0] res_temp;
  wire s7;
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i0 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s0 )
  );
  DIG_Sub #(
    .Bits(32)
  )
  DIG_Sub_i1 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s1 )
  );
  assign s2 = (a & b);
  assign s3 = (a | b);
  CompSigned #(
    .Bits(32)
  )
  CompSigned_i2 (
    .a( a ),
    .b( b ),
    .\< ( s7 )
  );
  assign s5 = (a ^ b);
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i3 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s6 )
  );
  assign s4[0] = s7;
  assign s4[31:1] = 31'b0;
  Mux_8x1_NBits #(
    .Bits(32)
  )
  Mux_8x1_NBits_i4 (
    .sel( op ),
    .in_0( s2 ),
    .in_1( s3 ),
    .in_2( s0 ),
    .in_3( s1 ),
    .in_4( s4 ),
    .in_5( s5 ),
    .in_6( s6 ),
    .in_7( 32'b0 ),
    .out( res_temp )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i5 (
    .a( res_temp ),
    .b( 32'b0 ),
    .\= ( isZero )
  );
  assign res = res_temp;
endmodule
module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule


module MemDecoder (
  input [31:0] VirtualAddress,
  input Enable,
  output [10:0] PhysicalAddress,
  output InvalidAddress
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire [31:0] s9;
  wire [31:0] s10;
  wire s11;
  wire [31:0] s12;
  wire [31:0] s13;
  wire [31:0] s14;
  wire s15;
  wire s16;
  wire [31:0] s17;
  // GM
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i0 (
    .a( VirtualAddress ),
    .b( 32'b10000000000000000000000000000 ),
    .\> ( s0 ),
    .\= ( s1 )
  );
  // GM
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i1 (
    .a( VirtualAddress ),
    .b( 32'b10000000000000000001111111111 ),
    .\= ( s2 ),
    .\< ( s3 )
  );
  // Stack
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i2 (
    .a( VirtualAddress ),
    .b( 32'b1111111111111111110111111111011 ),
    .\= ( s4 ),
    .\< ( s5 )
  );
  // Stack
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i3 (
    .a( VirtualAddress ),
    .b( 32'b1111111111111111110101111111100 ),
    .\> ( s6 ),
    .\= ( s7 )
  );
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i4 (
    .a( VirtualAddress ),
    .b( 32'b100 ),
    .c_i( 1'b0 ),
    .s( s12 )
  );
  assign s8 = ((s0 | s1) & (s2 | s3));
  assign s11 = ((s6 | s7) & (s4 | s5));
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i5 (
    .sel( s8 ),
    .in_0( 32'b0 ),
    .in_1( VirtualAddress ),
    .out( s9 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i6 (
    .sel( s11 ),
    .in_0( 32'b0 ),
    .in_1( s12 ),
    .out( s13 )
  );
  assign s15 = (~ s11 & ~ s8);
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i7 (
    .sel( Enable ),
    .in_0( 32'b0 ),
    .in_1( s9 ),
    .out( s10 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i8 (
    .sel( Enable ),
    .in_0( 32'b0 ),
    .in_1( s13 ),
    .out( s14 )
  );
  Mux_2x1 Mux_2x1_i9 (
    .sel( s15 ),
    .in_0( 1'b0 ),
    .in_1( 1'b1 ),
    .out( s16 )
  );
  Mux_2x1 Mux_2x1_i10 (
    .sel( Enable ),
    .in_0( 1'b0 ),
    .in_1( s16 ),
    .out( InvalidAddress )
  );
  assign s17 = (s10 | s14);
  assign PhysicalAddress = s17[10:0];
endmodule

module MIPS32SOC (
  input clk,
  input rst,
  output invalid_opcode,
  output invalid_addr,
  output invalid_pc
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [7:0] s2;
  wire [31:0] s3;
  wire [31:0] s4;
  wire [31:0] wData;
  wire RegWrite;
  wire [4:0] s5;
  wire [4:0] s6;
  wire [4:0] s7;
  wire [31:0] s8;
  wire [31:0] s9;
  wire [5:0] Func;
  wire [4:0] s10;
  wire [5:0] Opcode;
  wire [31:0] s11;
  wire [31:0] s12;
  wire [2:0] aluFunc;
  wire [31:0] s13;
  wire s14;
  wire [15:0] s15;
  wire [31:0] s16;
  wire aluSrc;
  wire RegDst;
  wire [2:0] aluOp;
  wire memWrite;
  wire memRead;
  wire memToReg;
  wire beq;
  wire jump;
  wire bne;
  wire [7:0] s17;
  wire [31:0] s18;
  wire [31:0] s19;
  wire [31:0] s20;
  wire s21;
  wire [31:0] s22;
  wire [31:0] s23;
  wire [1:0] const2b0;
  wire [33:0] s24;
  wire [27:0] s25;
  wire s26;
  wire [10:0] s27;
  wire [9:0] s28;
  assign const2b0 = 2'b0;
  assign invalid_opcode = 1'b0;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i0 (
    .sel( rst ),
    .in_0( s11 ),
    .in_1( 32'b10000000000000000000000 ),
    .out( s0 )
  );
  ControlUnit ControlUnit_i1 (
    .rst( rst ),
    .Opcode( Opcode ),
    .memWrite( memWrite ),
    .memRead( memRead ),
    .memToReg( memToReg ),
    .aluOp( aluOp ),
    .RegDst( RegDst ),
    .aluSrc( aluSrc ),
    .RegWrite( RegWrite ),
    .beq( beq ),
    .jump( jump ),
    .bne( bne )
  );
  assign s24[1:0] = const2b0;
  assign s24[33:2] = s16;
  // PC
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i2 (
    .D( s0 ),
    .C( clk ),
    .en( 1'b1 ),
    .Q( s1 )
  );
  assign s26 = (memWrite | memRead);
  assign s19 = s24[31:0];
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i3 (
    .a( s1 ),
    .b( 32'b100 ),
    .c_i( 1'b0 ),
    .s( s4 )
  );
  PCDecoder PCDecoder_i4 (
    .VirtualPC( s1 ),
    .PhysicalPC( s28 ),
    .InvalidPC( invalid_pc )
  );
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i5 (
    .a( s4 ),
    .b( s19 ),
    .c_i( 1'b0 ),
    .s( s20 )
  );
  assign s2 = s28[9:2];
  // InstMem
  DIG_ROM_256X32_InstMem DIG_ROM_256X32_InstMem_i6 (
    .A( s2 ),
    .sel( 1'b1 ),
    .D( s3 )
  );
  assign s25[1:0] = 2'b0;
  assign s25[27:2] = s3[25:0];
  assign Func = s3[5:0];
  assign s10 = s3[15:11];
  assign s7 = s3[20:16];
  assign s6 = s3[25:21];
  assign Opcode = s3[31:26];
  assign s15 = s3[15:0];
  DIG_BitExtender #(
    .inputBits(16),
    .outputBits(32)
  )
  DIG_BitExtender_i7 (
    .in( s15 ),
    .out( s16 )
  );
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i8 (
    .sel( RegDst ),
    .in_0( s7 ),
    .in_1( s10 ),
    .out( s5 )
  );
  ALUControl ALUControl_i9 (
    .aluOp( aluOp ),
    .Func( Func ),
    .aluFunc( aluFunc )
  );
  assign s23[27:0] = s25;
  assign s23[31:28] = s4[31:28];
  // Reg File
  DIG_RegisterFile #(
    .Bits(32),
    .AddrBits(5)
  )
  DIG_RegisterFile_i10 (
    .Din( wData ),
    .we( RegWrite ),
    .Rw( s5 ),
    .C( clk ),
    .Ra( s6 ),
    .Rb( s7 ),
    .Da( s8 ),
    .Db( s9 )
  );
  ALU ALU_i11 (
    .a( s8 ),
    .b( s12 ),
    .op( aluFunc ),
    .res( s13 ),
    .isZero( s14 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i12 (
    .sel( aluSrc ),
    .in_0( s9 ),
    .in_1( s16 ),
    .out( s12 )
  );
  // Data Mem
  DIG_RAMDualPort #(
    .Bits(32),
    .AddrBits(8)
  )
  DIG_RAMDualPort_i13 (
    .A( s17 ),
    .Din( s9 ),
    .str( memWrite ),
    .C( clk ),
    .ld( memRead ),
    .D( s18 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i14 (
    .sel( memToReg ),
    .in_0( s13 ),
    .in_1( s18 ),
    .out( wData )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i15 (
    .sel( s21 ),
    .in_0( s4 ),
    .in_1( s20 ),
    .out( s22 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i16 (
    .sel( jump ),
    .in_0( s22 ),
    .in_1( s23 ),
    .out( s11 )
  );
  assign s21 = ((beq & s14) | (bne & ~ s14));
  MemDecoder MemDecoder_i17 (
    .VirtualAddress( s13 ),
    .Enable( s26 ),
    .PhysicalAddress( s27 ),
    .InvalidAddress( invalid_addr )
  );
  assign s17 = s27[9:2];
endmodule
